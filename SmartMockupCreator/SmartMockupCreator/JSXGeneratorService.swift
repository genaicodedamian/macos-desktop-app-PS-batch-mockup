//
//  JSXGeneratorService.swift
//  SmartMockupCreator
//
//  Created by SmartMockupCreator on 2024-01-01.
//

import Foundation
import AppKit

struct JSXGenerationResult {
    let success: Bool
    let filePath: String?
    let errorMessage: String?
    
    static func success(filePath: String) -> JSXGenerationResult {
        return JSXGenerationResult(success: true, filePath: filePath, errorMessage: nil)
    }
    
    static func failure(error: String) -> JSXGenerationResult {
        return JSXGenerationResult(success: false, filePath: nil, errorMessage: error)
    }
}

class JSXGeneratorService: ObservableObject {
    
    // MARK: - Mockup Generator JSX Generation
    static func generateMockupScript(
        inputFolderPath: String,
        mockupFolderPath: String,
        smartObjectLayers: [SmartObjectLayer]
    ) -> JSXGenerationResult {
        
        // Walidacja danych wejściowych
        let validation = ValidationService.validateMockupGeneratorConfiguration(
            inputFolder: inputFolderPath,
            mockupFolder: mockupFolderPath,
            smartObjectLayers: smartObjectLayers
        )
        
        guard validation.isValid else {
            return .failure(error: validation.errorMessage ?? "Nieprawidłowa konfiguracja")
        }
        
        // Generowanie kodu JSX
        let jsxContent = buildMockupGeneratorJSX(
            inputFolderPath: inputFolderPath,
            mockupFolderPath: mockupFolderPath,
            smartObjectLayers: smartObjectLayers
        )
        
        // Zapisywanie pliku
        let fileName = generateFileName(prefix: "mockup_generator")
        return saveJSXFile(content: jsxContent, fileName: fileName)
    }
    
    private static func buildMockupGeneratorJSX(
        inputFolderPath: String,
        mockupFolderPath: String,
        smartObjectLayers: [SmartObjectLayer]
    ) -> String {
        
        let timestamp = DateFormatter.jsxTimestamp.string(from: Date())
        
        var jsx = """
        // Generated by Smart Mockup Creator
        // Date: \(timestamp)
        
        #include "Batch Mockup Smart Object Replacement.jsx"
        
        var outputOpts = {
          path: '$/_output',
          format: 'jpg',
          zeroPadding: true,
          filename: '@input_@mockup'
        };
        
        mockups([
        """
        
        // Generowanie konfiguracji dla każdego pliku mockup w folderze
        let mockupFiles = ValidationService.getFileNames(
            in: mockupFolderPath,
            withFormats: ValidationService.mockupFileFormats,
            limit: 1000
        )
        
        for (index, mockupFile) in mockupFiles.enumerated() {
            jsx += "\n  {\n"
            jsx += "    output: outputOpts,\n"
            jsx += "    mockupPath: '\(convertToJSXPath(mockupFolderPath))/\(mockupFile)',\n"
            jsx += "    smartObjects: [\n"
            
            // Generowanie konfiguracji dla każdej warstwy Smart Object
            for (layerIndex, layer) in smartObjectLayers.enumerated() {
                jsx += "      {\n"
                jsx += "        target: '\(layer.target)',\n"
                jsx += "        input: '\(convertToJSXPath(inputFolderPath))',\n"
                jsx += "        align: '\(layer.align)',\n"
                jsx += "        resize: '\(layer.resize)'\n"
                jsx += "      }"
                
                if layerIndex < smartObjectLayers.count - 1 {
                    jsx += ","
                }
                jsx += "\n"
            }
            
            jsx += "    ]\n"
            jsx += "  }"
            
            if index < mockupFiles.count - 1 {
                jsx += ","
            }
            jsx += "\n"
        }
        
        jsx += """
        ]);
        
        // Script completed successfully
        // Files processed: \(mockupFiles.count) mockup(s), \(smartObjectLayers.count) smart object layer(s)
        """
        
        return jsx
    }
    
    // MARK: - Smart Object Renamer JSX Generation
    static func generateRenamerScript(
        psdFolderPath: String,
        newLayerName: String
    ) -> JSXGenerationResult {
        
        // Walidacja danych wejściowych
        let validation = ValidationService.validateSmartObjectRenamerConfiguration(
            psdFolder: psdFolderPath,
            newLayerName: newLayerName
        )
        
        guard validation.isValid else {
            return .failure(error: validation.errorMessage ?? "Nieprawidłowa konfiguracja")
        }
        
        // Generowanie kodu JSX
        let jsxContent = buildSmartObjectRenamerJSX(
            psdFolderPath: psdFolderPath,
            newLayerName: newLayerName
        )
        
        // Zapisywanie pliku
        let fileName = generateFileName(prefix: "rename_smart_objects")
        return saveJSXFile(content: jsxContent, fileName: fileName)
    }
    
    private static func buildSmartObjectRenamerJSX(
        psdFolderPath: String,
        newLayerName: String
    ) -> String {
        
        let timestamp = DateFormatter.jsxTimestamp.string(from: Date())
        
        return """
        // Smart Object Layer Renamer Script
        // Generated by Smart Mockup Creator
        // Date: \(timestamp)
        
        // Configuration
        var config = {
          psdFolder: '\(convertToJSXPath(psdFolderPath))',
          newLayerName: '\(newLayerName)',
          logFile: '\(convertToJSXPath(psdFolderPath))/rename_log.txt'
        };
        
        // Initialize log
        var logContent = 'Smart Object Renamer Log\\n';
        logContent += 'Date: \(timestamp)\\n';
        logContent += 'Target folder: ' + config.psdFolder + '\\n';
        logContent += 'New layer name: ' + config.newLayerName + '\\n';
        logContent += '================================\\n\\n';
        
        function main() {
          try {
            var folder = new Folder(config.psdFolder);
            if (!folder.exists) {
              logContent += 'ERROR: Folder does not exist: ' + config.psdFolder + '\\n';
              writeLog();
              return;
            }
            
            var files = folder.getFiles('*.psd');
            var psbFiles = folder.getFiles('*.psb');
            files = files.concat(psbFiles);
            
            logContent += 'Found ' + files.length + ' PSD/PSB files\\n\\n';
            
            var processedCount = 0;
            var skippedCount = 0;
            var errorCount = 0;
            
            for (var i = 0; i < files.length; i++) {
              var file = files[i];
              var result = processFile(file);
              
              if (result.processed) {
                processedCount++;
              } else if (result.skipped) {
                skippedCount++;
              } else {
                errorCount++;
              }
            }
            
            logContent += '\\n================================\\n';
            logContent += 'SUMMARY:\\n';
            logContent += 'Processed: ' + processedCount + '\\n';
            logContent += 'Skipped: ' + skippedCount + '\\n';
            logContent += 'Errors: ' + errorCount + '\\n';
            
            writeLog();
            alert('Renaming completed!\\nProcessed: ' + processedCount + '\\nSkipped: ' + skippedCount + '\\nErrors: ' + errorCount + '\\nCheck rename_log.txt for details.');
            
          } catch (e) {
            logContent += 'FATAL ERROR: ' + e.toString() + '\\n';
            writeLog();
            alert('Fatal error occurred. Check rename_log.txt for details.');
          }
        }
        
        function processFile(file) {
          var result = { processed: false, skipped: false, error: false };
          
          try {
            logContent += 'Processing: ' + file.name + '\\n';
            
            var doc = app.open(file);
            var smartObjectLayers = findSmartObjectLayers(doc);
            
            if (smartObjectLayers.length === 0) {
              logContent += '  SKIPPED: No Smart Object layers found\\n';
              result.skipped = true;
            } else if (smartObjectLayers.length > 1) {
              logContent += '  SKIPPED: Multiple Smart Object layers found (' + smartObjectLayers.length + ')\\n';
              result.skipped = true;
            } else {
              var layer = smartObjectLayers[0];
              var oldName = layer.name;
              layer.name = config.newLayerName;
              logContent += '  SUCCESS: Renamed "' + oldName + '" to "' + config.newLayerName + '"\\n';
              doc.save();
              result.processed = true;
            }
            
            doc.close();
            
          } catch (e) {
            logContent += '  ERROR: ' + e.toString() + '\\n';
            result.error = true;
            try { doc.close(); } catch (e2) {}
          }
          
          return result;
        }
        
        function findSmartObjectLayers(doc) {
          var smartObjectLayers = [];
          
          function searchLayers(layers) {
            for (var i = 0; i < layers.length; i++) {
              var layer = layers[i];
              
              if (layer.typename === 'ArtLayer' && layer.kind === LayerKind.SMARTOBJECT) {
                smartObjectLayers.push(layer);
              } else if (layer.typename === 'LayerSet') {
                searchLayers(layer.layers);
              }
            }
          }
          
          searchLayers(doc.layers);
          return smartObjectLayers;
        }
        
        function writeLog() {
          try {
            var logFile = new File(config.logFile);
            logFile.open('w');
            logFile.write(logContent);
            logFile.close();
          } catch (e) {
            alert('Could not write log file: ' + e.toString());
          }
        }
        
        // Run the script
        main();
        """
    }
    
    // MARK: - Utility Functions
    private static func convertToJSXPath(_ path: String) -> String {
        // Konwertuje absolutną ścieżkę na format używany przez JSX
        // Dla uproszczenia używamy ścieżek bezwzględnych, ale można to rozszerzyć
        // o obsługę ścieżek względnych z prefiksami $ i .
        return path.replacingOccurrences(of: "\\", with: "/")
    }
    
    private static func generateFileName(prefix: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let timestamp = formatter.string(from: Date())
        return "\(prefix)_\(timestamp).jsx"
    }
    
    private static func saveJSXFile(content: String, fileName: String) -> JSXGenerationResult {
        let panel = NSSavePanel()
        panel.allowedContentTypes = [.init(filenameExtension: "jsx")!]
        panel.nameFieldStringValue = fileName
        panel.title = "Zapisz skrypt JSX"
        panel.prompt = "Zapisz"
        
        // Ustawienie domyślnej lokalizacji na Desktop
        panel.directoryURL = FileManager.default.urls(for: .desktopDirectory, in: .userDomainMask).first
        
        var result: JSXGenerationResult = .failure(error: "Anulowano zapisywanie")
        
        panel.begin { response in
            if response == .OK, let url = panel.url {
                do {
                    try content.write(to: url, atomically: true, encoding: .utf8)
                    result = .success(filePath: url.path)
                } catch {
                    result = .failure(error: "Nie można zapisać pliku: \(error.localizedDescription)")
                }
            }
        }
        
        return result
    }
    
    // MARK: - File Operations
    static func openInFinder(path: String) {
        let url = URL(fileURLWithPath: path)
        let folderURL = url.deletingLastPathComponent()
        NSWorkspace.shared.open(folderURL)
    }
    
    static func revealInFinder(path: String) {
        let url = URL(fileURLWithPath: path)
        NSWorkspace.shared.activateFileViewerSelecting([url])
    }
}

// MARK: - Extensions
extension DateFormatter {
    static let jsxTimestamp: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return formatter
    }()
}
