//
//  JSXGeneratorService.swift
//  SmartMockupCreator
//
//  Created by SmartMockupCreator on 2024-01-01.
//

import Foundation
import AppKit

struct JSXGenerationResult {
    let success: Bool
    let filePath: String?
    let errorMessage: String?
    
    static func success(filePath: String) -> JSXGenerationResult {
        return JSXGenerationResult(success: true, filePath: filePath, errorMessage: nil)
    }
    
    static func failure(error: String) -> JSXGenerationResult {
        return JSXGenerationResult(success: false, filePath: nil, errorMessage: error)
    }
}

class JSXGeneratorService: ObservableObject {
    
    // MARK: - Mockup Generator JSX Generation
    static func generateMockupScript(
        inputFolderPath: String,
        mockupFolderPath: String,
        outputFolderPath: String,
        outputFormat: String,
        smartObjectLayers: [SmartObjectLayer]
    ) -> JSXGenerationResult {
        
        // Walidacja danych wejściowych
        let validation = ValidationService.validateMockupGeneratorConfiguration(
            inputFolder: inputFolderPath,
            mockupFolder: mockupFolderPath,
            outputFolder: outputFolderPath,
            smartObjectLayers: smartObjectLayers
        )
        
        guard validation.isValid else {
            return .failure(error: validation.errorMessage ?? "Nieprawidłowa konfiguracja")
        }
        
        // Generowanie kodu JSX
        let jsxContent = buildMockupGeneratorJSX(
            inputFolderPath: inputFolderPath,
            mockupFolderPath: mockupFolderPath,
            outputFolderPath: outputFolderPath,
            outputFormat: outputFormat,
            smartObjectLayers: smartObjectLayers
        )
        
        // Zapisywanie pliku
        let fileName = generateFileName(prefix: "mockup_generator")
        return saveJSXFile(content: jsxContent, fileName: fileName)
    }
    
    private static func buildMockupGeneratorJSX(
        inputFolderPath: String,
        mockupFolderPath: String,
        outputFolderPath: String,
        outputFormat: String,
        smartObjectLayers: [SmartObjectLayer]
    ) -> String {
        
        let timestamp = DateFormatter.jsxTimestamp.string(from: Date())
        
        // Walidacja formatu wyjściowego - tylko obsługiwane formaty
        let finalFormat = validateOutputFormat(outputFormat)
        
        // Znajdź pełną ścieżkę do pliku silnika JSX
        let enginePath = getEngineFileAbsolutePath() ?? NSString(string: "~/Documents/projects/Smart objects PS replace/script/Batch Mockup Smart Object Replacement.jsx").expandingTildeInPath
        
        var jsx = """
        // Generated by Smart Mockup Creator
        // Date: \(timestamp)
        // Engine path: \(enginePath)
        
        #include "\(enginePath)"
        
        // Debug logging function
        function logDebug(message) {
          try {
            var logFile = new File(Folder.desktop + '/mockup_generator_debug.log');
            logFile.open('a');
            logFile.writeln(new Date().toString() + ': ' + message);
            logFile.close();
          } catch(e) {
            // Silent fail for logging
          }
        }
        
        // Validate engine file exists
        try {
          var engineFile = new File('\(enginePath)');
          if (!engineFile.exists) {
            alert('ERROR: Engine file not found!\\n\\nExpected location:\\n\(enginePath)\\n\\nPlease check if the file exists at this path.');
            logDebug('ERROR: Engine file not found at: \(enginePath)');
            throw new Error('Engine file not found');
          }
          logDebug('Engine file found at: \(enginePath)');
        } catch(e) {
          alert('Critical Error: ' + e.toString());
          throw e;
        }
        
        logDebug('Starting mockup generation with format: \(finalFormat)');
        
        var outputOpts = {
          path: '\(convertToJSXPath(outputFolderPath))',
          format: '\(finalFormat)',
          zeroPadding: true,
          filename: '@input_@mockup'
        };
        
        mockups([
        """
        
        // Generowanie konfiguracji dla każdego pliku mockup w folderze
        let mockupFiles = ValidationService.getFileNames(
            in: mockupFolderPath,
            withFormats: ValidationService.mockupFileFormats,
            limit: 1000
        )
        
        for (index, mockupFile) in mockupFiles.enumerated() {
            jsx += "\n  {\n"
            jsx += "    output: outputOpts,\n"
            jsx += "    mockupPath: '\(convertToJSXPath(mockupFolderPath))/\(mockupFile)',\n"
            jsx += "    smartObjects: [\n"
            
            // Generowanie konfiguracji dla każdej warstwy Smart Object
            for (layerIndex, layer) in smartObjectLayers.enumerated() {
                jsx += "      {\n"
                jsx += "        target: '\(layer.target)',\n"
                jsx += "        input: '\(convertToJSXPath(inputFolderPath))',\n"
                jsx += "        align: '\(layer.align)',\n"
                jsx += "        resize: '\(layer.resize)'\n"
                jsx += "      }"
                
                if layerIndex < smartObjectLayers.count - 1 {
                    jsx += ","
                }
                jsx += "\n"
            }
            
            jsx += "    ]\n"
            jsx += "  }"
            
            if index < mockupFiles.count - 1 {
                jsx += ","
            }
            jsx += "\n"
        }
        
        jsx += """
        ]);
        
        logDebug('Script completed successfully');
        logDebug('Files processed: \(mockupFiles.count) mockup(s), \(smartObjectLayers.count) smart object layer(s)');
        alert('Batch process completed!\\nProcessed: \(mockupFiles.count) mockup(s)\\nSmart Objects: \(smartObjectLayers.count) layer(s)\\nCheck Desktop for debug log if issues occur.');
        
        // Script completed successfully
        // Files processed: \(mockupFiles.count) mockup(s), \(smartObjectLayers.count) smart object layer(s)
        """
        
        return jsx
    }
    
    // MARK: - Smart Object Renamer JSX Generation
    static func generateRenamerScript(
        psdFolderPath: String,
        newLayerName: String
    ) -> JSXGenerationResult {
        
        // Walidacja danych wejściowych
        let validation = ValidationService.validateSmartObjectRenamerConfiguration(
            psdFolder: psdFolderPath,
            newLayerName: newLayerName
        )
        
        guard validation.isValid else {
            return .failure(error: validation.errorMessage ?? "Nieprawidłowa konfiguracja")
        }
        
        // Generowanie kodu JSX
        let jsxContent = buildSmartObjectRenamerJSX(
            psdFolderPath: psdFolderPath,
            newLayerName: newLayerName
        )
        
        // Zapisywanie pliku
        let fileName = generateFileName(prefix: "rename_smart_objects")
        return saveJSXFile(content: jsxContent, fileName: fileName)
    }
    
    private static func buildSmartObjectRenamerJSX(
        psdFolderPath: String,
        newLayerName: String
    ) -> String {
        
        let timestamp = DateFormatter.jsxTimestamp.string(from: Date())
        
        return """
        // Smart Object Layer Renamer Script
        // Generated by Smart Mockup Creator
        // Date: \(timestamp)
        
        // Configuration
        var config = {
          psdFolder: '\(convertToJSXPath(psdFolderPath))',
          newLayerName: '\(newLayerName)',
          logFile: '\(convertToJSXPath(psdFolderPath))/rename_log.txt'
        };
        
        // Initialize log
        var logContent = 'Smart Object Renamer Log\\n';
        logContent += 'Date: \(timestamp)\\n';
        logContent += 'Target folder: ' + config.psdFolder + '\\n';
        logContent += 'New layer name: ' + config.newLayerName + '\\n';
        logContent += '================================\\n\\n';
        
        function main() {
          try {
            var folder = new Folder(config.psdFolder);
            if (!folder.exists) {
              logContent += 'ERROR: Folder does not exist: ' + config.psdFolder + '\\n';
              writeLog();
              return;
            }
            
            var files = folder.getFiles('*.psd');
            var psbFiles = folder.getFiles('*.psb');
            files = files.concat(psbFiles);
            
            logContent += 'Found ' + files.length + ' PSD/PSB files\\n\\n';
            
            var processedCount = 0;
            var skippedCount = 0;
            var errorCount = 0;
            
            for (var i = 0; i < files.length; i++) {
              var file = files[i];
              var result = processFile(file);
              
              if (result.processed) {
                processedCount++;
              } else if (result.skipped) {
                skippedCount++;
              } else {
                errorCount++;
              }
            }
            
            logContent += '\\n================================\\n';
            logContent += 'SUMMARY:\\n';
            logContent += 'Processed: ' + processedCount + '\\n';
            logContent += 'Skipped: ' + skippedCount + '\\n';
            logContent += 'Errors: ' + errorCount + '\\n';
            
            writeLog();
            alert('Renaming completed!\\nProcessed: ' + processedCount + '\\nSkipped: ' + skippedCount + '\\nErrors: ' + errorCount + '\\nCheck rename_log.txt for details.');
            
          } catch (e) {
            logContent += 'FATAL ERROR: ' + e.toString() + '\\n';
            writeLog();
            alert('Fatal error occurred. Check rename_log.txt for details.');
          }
        }
        
        function processFile(file) {
          var result = { processed: false, skipped: false, error: false };
          
          try {
            logContent += 'Processing: ' + file.name + '\\n';
            
            var doc = app.open(file);
            var smartObjectLayers = findSmartObjectLayers(doc);
            
            if (smartObjectLayers.length === 0) {
              logContent += '  SKIPPED: No Smart Object layers found\\n';
              result.skipped = true;
            } else if (smartObjectLayers.length > 1) {
              logContent += '  SKIPPED: Multiple Smart Object layers found (' + smartObjectLayers.length + ')\\n';
              result.skipped = true;
            } else {
              var layer = smartObjectLayers[0];
              var oldName = layer.name;
              layer.name = config.newLayerName;
              logContent += '  SUCCESS: Renamed "' + oldName + '" to "' + config.newLayerName + '"\\n';
              doc.save();
              result.processed = true;
            }
            
            doc.close();
            
          } catch (e) {
            logContent += '  ERROR: ' + e.toString() + '\\n';
            result.error = true;
            try { doc.close(); } catch (e2) {}
          }
          
          return result;
        }
        
        function findSmartObjectLayers(doc) {
          var smartObjectLayers = [];
          
          function searchLayers(layers) {
            for (var i = 0; i < layers.length; i++) {
              var layer = layers[i];
              
              if (layer.typename === 'ArtLayer' && layer.kind === LayerKind.SMARTOBJECT) {
                smartObjectLayers.push(layer);
              } else if (layer.typename === 'LayerSet') {
                searchLayers(layer.layers);
              }
            }
          }
          
          searchLayers(doc.layers);
          return smartObjectLayers;
        }
        
        function writeLog() {
          try {
            var logFile = new File(config.logFile);
            logFile.open('w');
            logFile.write(logContent);
            logFile.close();
          } catch (e) {
            alert('Could not write log file: ' + e.toString());
          }
        }
        
        // Run the script
        main();
        """
    }
    
    // MARK: - Utility Functions
    private static func convertToJSXPath(_ path: String) -> String {
        // Konwertuje absolutną ścieżkę na format używany przez JSX
        // Escape'uje pojedyncze cudzysłowy i konwertuje backslash na forward slash
        return path.replacingOccurrences(of: "\\", with: "/")
                  .replacingOccurrences(of: "'", with: "\\'")
    }
    
    // MARK: - Format Validation
    static func getSupportedOutputFormats() -> [String] {
        return ["jpg", "png", "tif", "psd", "pdf"]
    }
    
    static func validateOutputFormat(_ format: String) -> String {
        let supportedFormats = getSupportedOutputFormats()
        let lowercaseFormat = format.lowercased()
        
        // Mapowanie popularnych wariantów
        switch lowercaseFormat {
        case "jpeg": return "jpg"
        case "tiff": return "tif"
        case "webp", "gif", "bmp": return "jpg" // Fallback dla nieobsługiwanych formatów
        default:
            return supportedFormats.contains(lowercaseFormat) ? lowercaseFormat : "jpg"
        }
    }
    
    private static func generateFileName(prefix: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        let timestamp = formatter.string(from: Date())
        return "\(prefix)_\(timestamp).jsx"
    }
    
    private static func saveJSXFile(content: String, fileName: String) -> JSXGenerationResult {
        let panel = NSSavePanel()
        panel.allowedContentTypes = [.init(filenameExtension: "jsx")!]
        panel.nameFieldStringValue = fileName
        panel.title = "Zapisz skrypt JSX"
        panel.prompt = "Zapisz"
        
        // Ustawienie domyślnej lokalizacji na Desktop
        panel.directoryURL = FileManager.default.urls(for: .desktopDirectory, in: .userDomainMask).first
        
        var result: JSXGenerationResult = .failure(error: "Anulowano zapisywanie")
        
        panel.begin { response in
            if response == .OK, let url = panel.url {
                do {
                    // Zapisz główny skrypt
                    try content.write(to: url, atomically: true, encoding: .utf8)
                    
                    // Opcjonalnie skopiuj plik silnika JSX do tego samego folderu (jako backup)
                    let targetFolder = url.deletingLastPathComponent()
                    let copySuccess = copyEngineFileToFolder(targetFolder)
                    
                    // Skrypt używa teraz pełnej ścieżki, więc kopiowanie nie jest krytyczne
                    if copySuccess {
                        print("Engine file copied successfully as backup")
                    } else {
                        print("Engine file copy failed, but script uses absolute path")
                    }
                    
                    result = .success(filePath: url.path)
                } catch {
                    result = .failure(error: "Nie można zapisać pliku: \(error.localizedDescription)")
                }
            }
        }
        
        return result
    }
    
    // MARK: - Engine File Management
    private static func copyEngineFileToFolder(_ targetFolder: URL) -> Bool {
        guard let engineSourceURL = getEngineFileURL() else {
            print("Engine file not found in project")
            return false
        }
        
        let engineDestinationURL = targetFolder.appendingPathComponent("Batch Mockup Smart Object Replacement.jsx")
        
        do {
            // Usuń istniejący plik jeśli istnieje
            if FileManager.default.fileExists(atPath: engineDestinationURL.path) {
                try FileManager.default.removeItem(at: engineDestinationURL)
            }
            
            // Skopiuj nowy plik
            try FileManager.default.copyItem(at: engineSourceURL, to: engineDestinationURL)
            print("Engine file copied successfully to: \(engineDestinationURL.path)")
            return true
        } catch {
            print("Failed to copy engine file: \(error.localizedDescription)")
            return false
        }
    }
    
    private static func getEngineFileURL() -> URL? {
        // Próbuj znaleźć plik w folderze script/ w głównym folderze projektu
        if let projectRoot = findProjectRoot() {
            let enginePath = projectRoot.appendingPathComponent("script/Batch Mockup Smart Object Replacement.jsx")
            if FileManager.default.fileExists(atPath: enginePath.path) {
                return enginePath
            }
        }
        
        // Alternatywnie, spróbuj znaleźć w bundle aplikacji
        if let bundlePath = Bundle.main.path(forResource: "Batch Mockup Smart Object Replacement", ofType: "jsx") {
            return URL(fileURLWithPath: bundlePath)
        }
        
        return nil
    }
    
    private static func getEngineFileAbsolutePath() -> String? {
        // Zwraca pełną ścieżkę bezwzględną do pliku silnika JSX
        if let engineURL = getEngineFileURL() {
            return engineURL.path
        }
        
        // Fallback - spróbuj znaleźć w typowych lokalizacjach
        let possiblePaths = [
            // W folderze użytkownika
            NSString(string: "~/Documents/projects/Smart objects PS replace/script/Batch Mockup Smart Object Replacement.jsx").expandingTildeInPath,
            // W folderze aplikacji lub workspace
            findProjectRoot()?.appendingPathComponent("script/Batch Mockup Smart Object Replacement.jsx").path,
            // W folderze desktop dla testów
            NSString(string: "~/Desktop/Smart objects PS replace/script/Batch Mockup Smart Object Replacement.jsx").expandingTildeInPath
        ].compactMap { $0 }
        
        for path in possiblePaths {
            if FileManager.default.fileExists(atPath: path) {
                return path
            }
        }
        
        // Ostatni fallback - zwróć najprawdopodobniejszą ścieżkę nawet jeśli plik nie istnieje
        // Użytkownik otrzyma komunikat błędu z pełną ścieżką
        return NSString(string: "~/Documents/projects/Smart objects PS replace/script/Batch Mockup Smart Object Replacement.jsx").expandingTildeInPath
    }
    
    private static func findProjectRoot() -> URL? {
        var currentURL = URL(fileURLWithPath: #file).deletingLastPathComponent()
        
        // Idź w górę aż znajdziesz folder z "script" lub osiągniesz root
        for _ in 0..<10 { // Maksymalnie 10 poziomów w górę
            let scriptFolder = currentURL.appendingPathComponent("script")
            if FileManager.default.fileExists(atPath: scriptFolder.path) {
                return currentURL
            }
            let parentURL = currentURL.deletingLastPathComponent()
            if parentURL == currentURL { break } // Osiągnięto root
            currentURL = parentURL
        }
        
        return nil
    }
    
    // MARK: - File Operations
    static func openInFinder(path: String) {
        let url = URL(fileURLWithPath: path)
        let folderURL = url.deletingLastPathComponent()
        NSWorkspace.shared.open(folderURL)
    }
    
    static func revealInFinder(path: String) {
        let url = URL(fileURLWithPath: path)
        NSWorkspace.shared.activateFileViewerSelecting([url])
    }
}

// MARK: - Extensions
extension DateFormatter {
    static let jsxTimestamp: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return formatter
    }()
}
